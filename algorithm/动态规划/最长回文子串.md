[5.最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

解法 1: 暴力

遍历字符串找到所有可能的子串，判断  `s[i::j]` 的字符串是否是回文串

实现一个算法来判断  `s[i::j]` 是否是回文串

```js
const validPalindrome = (charArr, left, right) => {
  while (left < right) {
    if (charArr[left] !== charArr[right]) return false;
    left++;
    right--;
  }
  return true;
};
```

遍历，保存目前最长的回文串长度，每次判断只需要判断更长的子串即可（剪枝）

```js
const longestPalindrome = (s) => {
  const charrArr = s.split("");
  let maxLen = 1;
  let begin = 0;

  for (let i = 0; i < charrArr.length - 1; i++) {
    for (let j = 1; j < charrArr.length; j++) {
      if (j - i + 1 > maxLen && validPalindrome(charrArr, i, j)) {
        maxLen = j - i + 1;
        begin = i;
      }
    }
  }

  return s.slice(begin, begin + maxLen);
};
```
