[5.最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

解法 1: 暴力

遍历字符串找到所有可能的子串，判断 `s[i::j]` 的字符串是否是回文串

实现一个算法来判断 `s[i::j]` 是否是回文串

```js
const validPalindrome = (charArr, left, right) => {
  while (left < right) {
    if (charArr[left] !== charArr[right]) return false;
    left++;
    right--;
  }
  return true;
};
```

遍历，保存目前最长的回文串长度，每次判断只需要判断更长的子串即可（剪枝）

时间复杂度 o(n3)，列举出所有的子串还需要进行一次回文判断

```js
const longestPalindrome = (s) => {
  const charrArr = s.split("");
  let maxLen = 1;
  let begin = 0;

  for (let i = 0; i < charrArr.length - 1; i++) {
    for (let j = 1; j < charrArr.length; j++) {
      if (j - i + 1 > maxLen && validPalindrome(charrArr, i, j)) {
        maxLen = j - i + 1;
        begin = i;
      }
    }
  }

  return s.slice(begin, begin + maxLen);
};
```

解法 2: 中位扩散法

最终的回文串可能是偶数位，也可能是奇数位，对于两种回文串，从中心位置出发，都可以扩散到其边界值

`abcab` 中心值为 c，起始扩散 i = 2

`abccab` 中心位置为 cc，起始扩散 i = 2, j = 3

因此我们可以遍历字符串中的每个字符，根据两种情况分情况讨论，找到每个字符串能到达的最大长度

当找到最大长度后，更新回文串的起始位置和结束位置

遍历完成后，即可获得最长回文子串

时间复杂度为 o(n2)，n 个字符，每个字符分两种情况扩散

```js
const expandAroundCenter = (charrArr, left, end) => {
  while (left >= 0 && right < charrArr.length && charrArr[left] === charrArr[right]) {
    right++;
    left--;
  }

  // 此时得到的 left,right 为边界条件
  // right - 1 - (left + 1) + 1
  return right - left - 1;
};
```

```js
const longestPalindrome = (s) => {
  let start = 0;
  let end = 0;
  const charrArr = s.split("");

  for (let i = 0; i < charrArr.length - 1; i++) {
    const len1 = expandAroundCenter(charrArr, i, i);
    const len2 = expandAroundCenter(charrArr, i, i + 1);
    const len = Math.max(len1, len2);
    if (end - start < len) {
      // 考虑奇数和偶数位，中心值减去长度的一半
      start = i - Math.floor((len - 1) / 2);
      end = i + len / 2;
    }
  }

  return s.slice(start, end + 1);
};
```
